% This MATLAB script performs the statistical analysis of ECG signal
% denoising algorithms. It uses the results table generated by
% 'ESG_ECG_filtering.m' to evaluate algorithm performance across
% multiple metrics and matrices (Brachial / Lumbar).

% The analysis includes:
%   1. Outlier removal (based on Metric 6, KR2)
%   2. Normality test (Kolmogorov–Smirnov)
%   3. Homogeneity test (Levene's test)
%   4. Non-parametric comparisons:
%       - Friedman test
%       - Pairwise Wilcoxon (Rank-Sum) tests

% Copyright 2025, Brain-Machine Interfaces Systems Lab,
% Universidad Miguel Hernández de Elche
% Desirée I. Gracia, Eduardo Iáñez, Mario Ortiz, Jose M. Azorin

% This software is provided under the MIT License:
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
%
% The above copyright notice and this permission notice shall be included
% in all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
% OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
% FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
% DEALINGS IN THE SOFTWARE.

% Load and Prepare Data
clear; clc; close all;
load('results_summary.mat', 'results');

% Convert columns to categorical arrays
algorithm  = categorical(results.Algorithm);
metric     = categorical(results.Metric);
subject    = categorical(results.Subject);
matrix     = categorical(results.Matrix);
repetition = categorical(results.Repetition);
value      = results.Value;

% Extract unique factor levels
metric_list     = unique(metric);
algorithm_list  = unique(algorithm);
matrix_list     = unique(matrix);
subject_list    = unique(subject);
repetition_list = unique(repetition);

% STEP 1: Outlier Removal (Based on Metric 6, KR2)

idx_metric6_1 = (metric == '6') & (algorithm == '1');
thresholds = [mean(value(idx_metric6_1), 'omitnan'), -quantile(value(idx_metric6_1), 0.15)];

num_out = zeros(length(algorithm_list), length(matrix_list), 1);

for mat = 1:length(matrix_list)
    for alg = 2:length(algorithm_list)  % Skip baseline algorithm (1)
        idx_metric6 = (metric == '6') & (algorithm == algorithm_list(alg)) & (matrix == matrix_list(mat));
        values_metric6 = value(idx_metric6);
        outliers = values_metric6 < thresholds(2) | values_metric6 > thresholds(1);
        num_out(alg,mat)=sum(outliers);
        % Apply removal to all metrics for only the identified repetitions
        for  m = 1:length(metric_list)
            idx_all_metrics = (metric == metric_list(m) & ...
                algorithm == algorithm_list(alg) & ...
                matrix == matrix_list(mat));

            % Get the indices of the repetitions that contain outliers
            repetition_outliers = find(idx_all_metrics);  % Get the full dataset indices
            repetition_outliers = repetition_outliers(outliers); % Keep only outlier repetitions

            % Set all metrics in this repetition to NaN
            value(repetition_outliers) = NaN;
        end
    end
end

% STEP 2: Normality Test (Kolmogorov–Smirnov)

p_KS = NaN(length(metric_list), length(algorithm_list), length(matrix_list));

for m = 1:length(metric_list)
    for alg = 1:length(algorithm_list)
        for mat = 1:length(matrix_list)
            subset = value(metric == metric_list(m) & algorithm == algorithm_list(alg) & matrix == matrix_list(mat));

            if numel(subset) > 10 && sum(~isnan(subset)) > 5
                norm_subset = (subset - mean(subset, 'omitnan')) / std(subset, 'omitnan');
                try
                    [~, p_KS(m, alg, mat)] = kstest(norm_subset);
                catch
                    warning('KS test failed for Metric %s, Algorithm %s, Matrix %s', ...
                        string(metric_list(m)), string(algorithm_list(alg)), string(matrix_list(mat)));
                end
            end
        end
    end
end

% STEP 3: Homogeneity Test (Levene's Test)

p_L = NaN(length(metric_list), length(matrix_list));

for m = 1:length(metric_list)
    for mat = 1:length(matrix_list)
        valid_idx = (metric == metric_list(m)) & (algorithm ~= categorical("1")) & (matrix == matrix_list(mat));
        subset = value(valid_idx);
        group = algorithm(valid_idx);

        % Remove NaN values
        validData = ~isnan(subset);
        subset = subset(validData);
        group = cellstr(group(validData));

        if numel(unique(group)) > 1
            try
                p_L(m, mat) = vartestn(subset, group, 'TestType', 'LeveneAbsolute');
            catch
                warning('Levene test failed for Metric %s, Matrix %s', string(metric_list(m)), string(matrix_list(mat)));
            end
        end
    end
end

% STEP 4: Statistical Analysis (Friedman & Wilcoxon Tests)

p_friedman = NaN(length(metric_list), length(matrix_list));
p_wilcox = NaN(length(algorithm_list), length(algorithm_list)-1, length(metric_list), length(matrix_list));
rvalue     = p_wilcox; % same size, for effect sizes

for m = 1:length(metric_list)
    for mat = 1:length(matrix_list)
        valid_idx = (metric == metric_list(m)) & (matrix == matrix_list(mat));
        subset = value(valid_idx);
        group1 = algorithm(valid_idx);
        group2 = subject(valid_idx);
        group3 = repetition(valid_idx);

        unique_algorithms = unique(group1);
        unique_subjects = unique(group2);
        num_algorithms = length(unique_algorithms);
        num_subjects = length(unique_subjects);

        if num_algorithms > 1 && num_subjects > 1
            friedman_data = NaN(2 * num_subjects, num_algorithms);

            for i = 1:num_subjects
                for j = 2:num_algorithms   % Skip baseline algorithm (1)
                    for x = 1:length(repetition_list)
                        idx = (group2 == unique_subjects(i)) & (group1 == unique_algorithms(j)) & (group3 == repetition_list(x));
                        if any(idx)
                            friedman_data((i-1)*2+x, j) = median(subset(idx), 'omitnan');
                        end
                    end
                end
            end

            % Check for missing values in Friedman test data
            if all(~isnan(friedman_data), 'all')
                fprintf('Performing Friedman Test for Metric %s, Matrix %s...\n', string(metric_list(m)), string(matrix_list(mat)));
                p_friedman(m, mat) = friedman(friedman_data(:,2:end), 2, 'off');

                if p_friedman(m, mat) < 0.05
                    fprintf('Performing pairwise comparisons...\n');
                    for i = 1:num_algorithms-1
                        for j = i+1:num_algorithms
                            vals1 = value((metric == metric_list(m)) & (matrix == matrix_list(mat)) & (algorithm == algorithm_list(i)));
                            vals2 = value((metric == metric_list(m)) & (matrix == matrix_list(mat)) & (algorithm == algorithm_list(j)));

                            [p_wilcox(j,i,m,mat),~,stats_values] = ranksum(vals1, vals2);
                            rvalue(j,i,m,mat)=stats_values.zval/sqrt(sum(~isnan(vals1))+sum(~isnan(vals2)));
                            fprintf('Comparison Algorithm %s vs. %s: P-value = %.4f\n', ...
                                string(unique_algorithms(i)), string(unique_algorithms(j)), p_wilcox(j, i, m, mat));

                        end
                    end
                end
            else
                warning('Skipping Friedman Test for Metric %s, Matrix %s due to missing values.', ...
                    string(metric_list(m)), string(matrix_list(mat)));
            end
        end
    end
end

% STEP 5: Matrix Comparison (Friedman Test Between Matrices)

p_friedman_mat = NaN(length(metric_list), length(algorithm_list));
p_wilcox_mat = NaN(length(matrix_list), length(matrix_list)-1,length(metric_list), length(algorithm_list));
rvalue_mat     = p_wilcox_mat;

for m = 1:length(metric_list)
    for alg = 1:length(algorithm_list)
        valid_idx = (metric == metric_list(m)) & (algorithm == algorithm_list(alg));
        subset = value(valid_idx);
        group1 = matrix(valid_idx);
        group2 = subject(valid_idx);
        group3 = repetition(valid_idx);

        unique_matrix= unique(group1);
        unique_subjects = unique(group2);
        num_matrix = length(unique_matrix);
        num_subjects = length(unique_subjects);

        if num_matrix > 1 && num_subjects > 1
            friedman_data = NaN(2 * num_subjects, num_matrix);

            for i = 1:num_subjects
                for j = 1:num_matrix
                    for x = 1:length(repetition_list)
                        idx = (group2 == unique_subjects(i)) & (group1 == unique_matrix(j)) & (group3 == repetition_list(x));
                        if any(idx)
                            friedman_data((i-1)*2+x, j) = median(subset(idx), 'omitnan');
                        end
                    end
                end
            end

            % Check for missing values in Friedman test data

            fprintf('Performing Friedman Test for Metric %s, Matrix %s...\n', string(metric_list(m)), string(matrix_list(mat)));
            valid=~isnan(sum(friedman_data'));
            p_friedman_mat(m,alg) = friedman(friedman_data(valid,:), 2, 'off');

            % if p_friedman(m, mat) < 0.05
            fprintf('Performing pairwise comparisons...\n');

            for i = 1:num_matrix-1
                for j = i+1:num_matrix
                    vals1 = value((metric == metric_list(m)) & (matrix == matrix_list(i)) & (algorithm == algorithm_list(alg)));
                    vals2 = value((metric == metric_list(m)) & (matrix == matrix_list(j)) & (algorithm == algorithm_list(alg)));

                    [p_wilcox_mat(j,i,m,alg),~,stats_values] = ranksum(vals1, vals2);
                    rvalue_mat(j,i,m,alg)=stats_values.zval/sqrt(sum(~isnan(vals1))+sum(~isnan(vals2)));
                    fprintf('Comparison Algorithm %s vs. %s: P-value = %.4f\n', ...
                        string(unique_algorithms(i)), string(unique_algorithms(j)), p_wilcox(j, i, m, mat));
                end
            end

        end
    end
end


% STEP 6: Save Results (Structured Output)
algorithms_labels = {
    'Frequentially filtered data (Raw data)'
    'Template Subtraction (TS)'
    'Adaptive Template Subtraction (ATS)'
    'High-pass filter with 200 Hz cutoff frequency (HP200)'
    'Adaptive Template Subtraction and subsequent high-pass filtering (ATS + HP200)'
    'Second order Extended Kalman Smoother (EKS2)'
    'Stationary Wavelet Transform (SWT)'
    'Empirical Mode Decomposition (EMD)'};

matrix_labels = {
    '64-electrode Brachial Plexus'
    '32-electrode Brachial Plexus'
    '32-electrode Lumbar Plexus'};

metric_labels = {
    'Relative Error (RE)'
    'Signal-to-Noise Ratio (SNR)'
    'Cross-Correlation (CC)'
    'Spectral Distortion (SD) [0, 20] Hz'
    'Spectral Distortion (SD) [20, 200] Hz'
    'Kurtosis Ratio (KR2)'
    'Variation of Kurtosis Ratio (ΔKR2)'};

% --- Normality (Kolmogorov–Smirnov)
Stats.Step2_KS.pvalues = p_KS;
Stats.Step2_KS.labels = struct( ...
    'dim1_metric', struct('codes', {cellstr(metric_list)}, 'names', {metric_labels}), ...
    'dim2_algorithm', struct('codes', {cellstr(algorithm_list)}, 'names', {algorithms_labels}), ...
    'dim3_matrix', struct('codes', {cellstr(matrix_list)}, 'names', {matrix_labels}), ...
    'description', 'STEP 1: Kolmogorov–Smirnov test for normality. Dimensions: 1=Metric, 2=Algorithm, 3=Matrix');

% --- Homogeneity (Levene's Test)
Stats.Step3_Levene.pvalues = p_L;
Stats.Step3_Levene.labels = struct( ...
    'dim1_metric', struct('codes', {cellstr(metric_list)}, 'names', {metric_labels}), ...
    'dim2_matrix', struct('codes', {cellstr(matrix_list)}, 'names', {matrix_labels}), ...
    'description', 'STEP 2: Levene''s test for homogeneity of variance. Dimensions: 1=Metric, 2=Matrix');

% --- Friedman Test (Algorithm Comparison)
Stats.Step4_Algorithm_Friedman.pvalues = p_friedman;
Stats.Step4_Algorithm_Friedman.labels = struct( ...
    'dim1_metric', struct('codes', {cellstr(metric_list)}, 'names', {metric_labels}), ...
    'dim2_matrix', struct('codes', {cellstr(matrix_list)}, 'names', {matrix_labels}), ...
    'description', 'STEP 3: Friedman test across algorithms. Dimensions: 1=Metric, 2=Matrix');

% --- Wilcoxon Pairwise Comparisons (Between Algorithms)
Stats.Step4_Algorithm_WilcoxonPairwise.pvalues = p_wilcox;
Stats.Step4_Algorithm_WilcoxonPairwise.rValues = rvalue;
Stats.Step4_Algorithm_WilcoxonPairwise.labels = struct( ...
    'dim1_algorithm', struct('codes', {cellstr(algorithm_list)}, 'names', {algorithms_labels}), ...
    'dim2_algorithm', struct('codes', {cellstr(algorithm_list(2:end))}, 'names', {algorithms_labels(2:end)}), ...
    'dim3_metric', struct('codes', {cellstr(metric_list)}, 'names', {metric_labels}), ...
    'dim4_matrix', struct('codes', {cellstr(matrix_list)}, 'names', {matrix_labels}), ...
    'description', 'Pairwise Wilcoxon rank-sum comparisons and effect sizes. Dimensions: 1=Algorithm, 2=Algorithm, 3=Metric, 4=Matrix');

% --- Friedman Test (Matrix Comparison)
Stats.Step5_Matrix_Friedman.pvalues = p_friedman_mat;
Stats.Step5_Matrix_Friedman.labels = struct( ...
    'dim1_metric', struct('codes', {cellstr(metric_list)}, 'names', {metric_labels}), ...
    'dim2_algorithm', struct('codes', {cellstr(matrix_list)}, 'names', {matrix_labels}), ...
    'description', 'STEP 4: Friedman test across matrices. Dimensions: 1=Metric, 2=Algorithm');

% --- Wilcoxon Pairwise Comparisons (Between Matrices)
Stats.Step5_Matrix_WilcoxonPairwise.pvalues = p_wilcox_mat;
Stats.Step5_Matrix_WilcoxonPairwise.rValues = rvalue_mat;
Stats.Step5_Matrix_WilcoxonPairwise.labels = struct( ...
    'dim1_matrix', struct('codes', {cellstr(matrix_list)}, 'names', {matrix_labels}), ...
    'dim2_matrix', struct('codes', {cellstr(matrix_list(2:end))}, 'names', {matrix_labels(2:end)}), ...
    'dim3_metric', struct('codes', {cellstr(metric_list)}, 'names', {metric_labels}), ...
    'dim1_algorithm', struct('codes', {cellstr(algorithm_list)}, 'names', {algorithms_labels}), ...
    'description', 'STEP 4: Friedman test across matrices. Dimensions: 1=Matrix, 2=Matrix, 3=Metric, 4=Algorithm');

% Save Structured Results
save('statistical_results.mat', 'Stats');
